/*!
 * Socket.IO v4.4.1
 * (c) 2014-2022 Guillermo Rauch
 * Released under the MIT License.
 */
!(function (t, e) {
  typeof exports === 'object' && typeof module !== 'undefined'
    ? (module.exports = e())
    : typeof define === 'function' && define.amd
      ? define(e)
      : ((t = typeof globalThis !== 'undefined' ? globalThis : t || self).io = e());
})(this, function () {
  'use strict';

  function t(e) {
    return (
      (t =
        typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
          ? function (t) {
            return typeof t;
          }
          : function (t) {
            return t &&
              typeof Symbol === 'function' &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? 'symbol'
              : typeof t;
          }),
      t(e)
    );
  }
  function e(t, e) {
    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function');
  }
  function n(t, e) {
    for (let n = 0; n < e.length; n++) {
      const r = e[n];
      (r.enumerable = r.enumerable || !1),
        (r.configurable = !0),
        'value' in r && (r.writable = !0),
        Object.defineProperty(t, r.key, r);
    }
  }
  function r(t, e, r) {
    return e && n(t.prototype, e), r && n(t, r), t;
  }
  function o() {
    return (
      (o =
        Object.assign ||
        function (t) {
          for (let e = 1; e < arguments.length; e++) {
            const n = arguments[e];
            for (const r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
          }
          return t;
        }),
      o.apply(this, arguments)
    );
  }
  function i(t, e) {
    if (typeof e !== 'function' && e !== null)
      throw new TypeError('Super expression must either be null or a function');
    (t.prototype = Object.create(e && e.prototype, {
      constructor: { value: t, writable: !0, configurable: !0 },
    })),
      e && a(t, e);
  }
  function s(t) {
    return (
      (s = Object.setPrototypeOf
        ? Object.getPrototypeOf
        : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        }),
      s(t)
    );
  }
  function a(t, e) {
    return (
      (a =
        Object.setPrototypeOf ||
        function (t, e) {
          return (t.__proto__ = e), t;
        }),
      a(t, e)
    );
  }
  function c(t) {
    if (void 0 === t)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return t;
  }
  function u(t, e) {
    if (e && (typeof e === 'object' || typeof e === 'function')) return e;
    if (void 0 !== e)
      throw new TypeError('Derived constructors may only return object or undefined');
    return c(t);
  }
  function h(t) {
    const e = (function () {
      if (typeof Reflect === 'undefined' || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if (typeof Proxy === 'function') return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })), !0;
      } catch (t) {
        return !1;
      }
    })();
    return function () {
      let n,
        r = s(t);
      if (e) {
        const o = s(this).constructor;
        n = Reflect.construct(r, arguments, o);
      } else n = r.apply(this, arguments);
      return u(this, n);
    };
  }
  function f(t, e, n) {
    return (
      (f =
        typeof Reflect !== 'undefined' && Reflect.get
          ? Reflect.get
          : function (t, e, n) {
            const r = (function (t, e) {
              for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = s(t)) !== null;);
              return t;
            })(t, e);
            if (r) {
              const o = Object.getOwnPropertyDescriptor(r, e);
              return o.get ? o.get.call(n) : o.value;
            }
          }),
      f(t, e, n || t)
    );
  }
  function l(t, e) {
    (e == null || e > t.length) && (e = t.length);
    for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
    return r;
  }
  function p(t, e) {
    let n = (typeof Symbol !== 'undefined' && t[Symbol.iterator]) || t['@@iterator'];
    if (!n) {
      if (
        Array.isArray(t) ||
        (n = (function (t, e) {
          if (t) {
            if (typeof t === 'string') return l(t, e);
            let n = Object.prototype.toString.call(t).slice(8, -1);
            return (
              n === 'Object' && t.constructor && (n = t.constructor.name),
              n === 'Map' || n === 'Set'
                ? Array.from(t)
                : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                  ? l(t, e)
                  : void 0
            );
          }
        })(t)) ||
        (e && t && typeof t.length === 'number')
      ) {
        n && (t = n);
        let r = 0,
          o = function () { };
        return {
          s: o,
          n() {
            return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] };
          },
          e(t) {
            throw t;
          },
          f: o,
        };
      }
      throw new TypeError(
        'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
      );
    }
    let i,
      s = !0,
      a = !1;
    return {
      s() {
        n = n.call(t);
      },
      n() {
        const t = n.next();
        return (s = t.done), t;
      },
      e(t) {
        (a = !0), (i = t);
      },
      f() {
        try {
          s || n.return == null || n.return();
        } finally {
          if (a) throw i;
        }
      },
    };
  }
  const d =
    /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
    y = [
      'source',
      'protocol',
      'authority',
      'userInfo',
      'user',
      'password',
      'host',
      'port',
      'relative',
      'path',
      'directory',
      'file',
      'query',
      'anchor',
    ],
    v = function (t) {
      const e = t,
        n = t.indexOf('['),
        r = t.indexOf(']');
      n != -1 &&
        r != -1 &&
        (t = t.substring(0, n) + t.substring(n, r).replace(/:/g, ';') + t.substring(r, t.length));
      for (var o, i, s = d.exec(t || ''), a = {}, c = 14; c--;) a[y[c]] = s[c] || '';
      return (
        n != -1 &&
        r != -1 &&
        ((a.source = e),
          (a.host = a.host.substring(1, a.host.length - 1).replace(/;/g, ':')),
          (a.authority = a.authority.replace('[', '').replace(']', '').replace(/;/g, ':')),
          (a.ipv6uri = !0)),
        (a.pathNames = (function (t, e) {
          const n = /\/{2,9}/g,
            r = e.replace(n, '/').split('/');
          (e.substr(0, 1) != '/' && e.length !== 0) || r.splice(0, 1);
          e.substr(e.length - 1, 1) == '/' && r.splice(r.length - 1, 1);
          return r;
        })(0, a.path)),
        (a.queryKey =
          ((o = a.query),
            (i = {}),
            o.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function (t, e, n) {
              e && (i[e] = n);
            }),
            i)),
        a
      );
    };
  const m = { exports: {} };
  try {
    m.exports = typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest();
  } catch (t) {
    m.exports = !1;
  }
  const g = m.exports,
    k =
      typeof self !== 'undefined'
        ? self
        : typeof window !== 'undefined'
          ? window
          : Function('return this')();
  function b(t) {
    const e = t.xdomain;
    try {
      if (typeof XMLHttpRequest !== 'undefined' && (!e || g)) return new XMLHttpRequest();
    } catch (t) { }
    if (!e)
      try {
        return new k[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
      } catch (t) { }
  }
  function w(t) {
    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
      n[r - 1] = arguments[r];
    return n.reduce(function (e, n) {
      return t.hasOwnProperty(n) && (e[n] = t[n]), e;
    }, {});
  }
  const _ = setTimeout,
    E = clearTimeout;
  function A(t, e) {
    e.useNativeTimers
      ? ((t.setTimeoutFn = _.bind(k)), (t.clearTimeoutFn = E.bind(k)))
      : ((t.setTimeoutFn = setTimeout.bind(k)), (t.clearTimeoutFn = clearTimeout.bind(k)));
  }
  const R = T;
  function T(t) {
    if (t)
      return (function (t) {
        for (const e in T.prototype) t[e] = T.prototype[e];
        return t;
      })(t);
  }
  (T.prototype.on = T.prototype.addEventListener =
    function (t, e) {
      return (
        (this._callbacks = this._callbacks || {}),
        (this._callbacks[`$${t}`] = this._callbacks[`$${t}`] || []).push(e),
        this
      );
    }),
    (T.prototype.once = function (t, e) {
      function n() {
        this.off(t, n), e.apply(this, arguments);
      }
      return (n.fn = e), this.on(t, n), this;
    }),
    (T.prototype.off =
      T.prototype.removeListener =
      T.prototype.removeAllListeners =
      T.prototype.removeEventListener =
      function (t, e) {
        if (((this._callbacks = this._callbacks || {}), arguments.length == 0))
          return (this._callbacks = {}), this;
        let n,
          r = this._callbacks[`$${t}`];
        if (!r) return this;
        if (arguments.length == 1) return delete this._callbacks[`$${t}`], this;
        for (let o = 0; o < r.length; o++)
          if ((n = r[o]) === e || n.fn === e) {
            r.splice(o, 1);
            break;
          }
        return r.length === 0 && delete this._callbacks[`$${t}`], this;
      }),
    (T.prototype.emit = function (t) {
      this._callbacks = this._callbacks || {};
      for (
        var e = new Array(arguments.length - 1), n = this._callbacks[`$${t}`], r = 1;
        r < arguments.length;
        r++
      )
        e[r - 1] = arguments[r];
      if (n) {
        r = 0;
        for (let o = (n = n.slice(0)).length; r < o; ++r) n[r].apply(this, e);
      }
      return this;
    }),
    (T.prototype.emitReserved = T.prototype.emit),
    (T.prototype.listeners = function (t) {
      return (this._callbacks = this._callbacks || {}), this._callbacks[`$${t}`] || [];
    }),
    (T.prototype.hasListeners = function (t) {
      return !!this.listeners(t).length;
    });
  const C = Object.create(null);
  (C.open = '0'),
    (C.close = '1'),
    (C.ping = '2'),
    (C.pong = '3'),
    (C.message = '4'),
    (C.upgrade = '5'),
    (C.noop = '6');
  const O = Object.create(null);
  Object.keys(C).forEach(function (t) {
    O[C[t]] = t;
  });
  for (
    var S = { type: 'error', data: 'parser error' },
    B =
      typeof Blob === 'function' ||
      (typeof Blob !== 'undefined' &&
        Object.prototype.toString.call(Blob) === '[object BlobConstructor]'),
    N = typeof ArrayBuffer === 'function',
    x = function (t, e, n) {
      let r,
        o = t.type,
        i = t.data;
      return B && i instanceof Blob
        ? e
          ? n(i)
          : L(i, n)
        : N &&
          (i instanceof ArrayBuffer ||
            ((r = i),
              typeof ArrayBuffer.isView === 'function'
                ? ArrayBuffer.isView(r)
                : r && r.buffer instanceof ArrayBuffer))
          ? e
            ? n(i)
            : L(new Blob([i]), n)
          : n(C[o] + (i || ''));
    },
    L = function (t, e) {
      const n = new FileReader();
      return (
        (n.onload = function () {
          const t = n.result.split(',')[1];
          e(`b${t}`);
        }),
        n.readAsDataURL(t)
      );
    },
    j = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
    P = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256),
    q = 0;
    q < j.length;
    q++
  )
    P[j.charCodeAt(q)] = q;
  var D,
    I = typeof ArrayBuffer === 'function',
    F = function (t, e) {
      if (typeof t !== 'string') return { type: 'message', data: U(t, e) };
      const n = t.charAt(0);
      return n === 'b'
        ? { type: 'message', data: M(t.substring(1), e) }
        : O[n]
          ? t.length > 1
            ? { type: O[n], data: t.substring(1) }
            : { type: O[n] }
          : S;
    },
    M = function (t, e) {
      if (I) {
        const n = (function (t) {
          let e,
            n,
            r,
            o,
            i,
            s = 0.75 * t.length,
            a = t.length,
            c = 0;
          t[t.length - 1] === '=' && (s--, t[t.length - 2] === '=' && s--);
          const u = new ArrayBuffer(s),
            h = new Uint8Array(u);
          for (e = 0; e < a; e += 4)
            (n = P[t.charCodeAt(e)]),
              (r = P[t.charCodeAt(e + 1)]),
              (o = P[t.charCodeAt(e + 2)]),
              (i = P[t.charCodeAt(e + 3)]),
              (h[c++] = (n << 2) | (r >> 4)),
              (h[c++] = ((15 & r) << 4) | (o >> 2)),
              (h[c++] = ((3 & o) << 6) | (63 & i));
          return u;
        })(t);
        return U(n, e);
      }
      return { base64: !0, data: t };
    },
    U = function (t, e) {
      return e === 'blob' && t instanceof ArrayBuffer ? new Blob([t]) : t;
    },
    V = String.fromCharCode(30),
    H = (function (t) {
      i(o, t);
      const n = h(o);
      function o(t) {
        let r;
        return (
          e(this, o),
          ((r = n.call(this)).writable = !1),
          A(c(r), t),
          (r.opts = t),
          (r.query = t.query),
          (r.readyState = ''),
          (r.socket = t.socket),
          r
        );
      }
      return (
        r(o, [
          {
            key: 'onError',
            value(t, e) {
              const n = new Error(t);
              return (
                (n.type = 'TransportError'),
                (n.description = e),
                f(s(o.prototype), 'emit', this).call(this, 'error', n),
                this
              );
            },
          },
          {
            key: 'open',
            value() {
              return (
                (this.readyState !== 'closed' && this.readyState !== '') ||
                ((this.readyState = 'opening'), this.doOpen()),
                this
              );
            },
          },
          {
            key: 'close',
            value() {
              return (
                (this.readyState !== 'opening' && this.readyState !== 'open') ||
                (this.doClose(), this.onClose()),
                this
              );
            },
          },
          {
            key: 'send',
            value(t) {
              this.readyState === 'open' && this.write(t);
            },
          },
          {
            key: 'onOpen',
            value() {
              (this.readyState = 'open'),
                (this.writable = !0),
                f(s(o.prototype), 'emit', this).call(this, 'open');
            },
          },
          {
            key: 'onData',
            value(t) {
              const e = F(t, this.socket.binaryType);
              this.onPacket(e);
            },
          },
          {
            key: 'onPacket',
            value(t) {
              f(s(o.prototype), 'emit', this).call(this, 'packet', t);
            },
          },
          {
            key: 'onClose',
            value() {
              (this.readyState = 'closed'), f(s(o.prototype), 'emit', this).call(this, 'close');
            },
          },
        ]),
        o
      );
    })(R),
    K = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''),
    Y = {},
    z = 0,
    $ = 0;
  function W(t) {
    let e = '';
    do {
      (e = K[t % 64] + e), (t = Math.floor(t / 64));
    } while (t > 0);
    return e;
  }
  function J() {
    const t = W(+new Date());
    return t !== D ? ((z = 0), (D = t)) : `${t}.${W(z++)}`;
  }
  for (; $ < 64; $++) Y[K[$]] = $;
  (J.encode = W),
    (J.decode = function (t) {
      let e = 0;
      for ($ = 0; $ < t.length; $++) e = 64 * e + Y[t.charAt($)];
      return e;
    });
  const X = J,
    G = {
      encode(t) {
        let e = '';
        for (const n in t)
          t.hasOwnProperty(n) &&
            (e.length && (e += '&'), (e += `${encodeURIComponent(n)}=${encodeURIComponent(t[n])}`));
        return e;
      },
      decode(t) {
        for (var e = {}, n = t.split('&'), r = 0, o = n.length; r < o; r++) {
          const i = n[r].split('=');
          e[decodeURIComponent(i[0])] = decodeURIComponent(i[1]);
        }
        return e;
      },
    },
    Q = (function (t) {
      i(o, t);
      const n = h(o);
      function o() {
        let t;
        return e(this, o), ((t = n.apply(this, arguments)).polling = !1), t;
      }
      return (
        r(o, [
          {
            key: 'name',
            get() {
              return 'polling';
            },
          },
          {
            key: 'doOpen',
            value() {
              this.poll();
            },
          },
          {
            key: 'pause',
            value(t) {
              const e = this;
              this.readyState = 'pausing';
              const n = function () {
                (e.readyState = 'paused'), t();
              };
              if (this.polling || !this.writable) {
                let r = 0;
                this.polling &&
                  (r++,
                    this.once('pollComplete', function () {
                      --r || n();
                    })),
                  this.writable ||
                  (r++,
                    this.once('drain', function () {
                      --r || n();
                    }));
              } else n();
            },
          },
          {
            key: 'poll',
            value() {
              (this.polling = !0), this.doPoll(), this.emit('poll');
            },
          },
          {
            key: 'onData',
            value(t) {
              const e = this;
              (function (t, e) {
                for (var n = t.split(V), r = [], o = 0; o < n.length; o++) {
                  const i = F(n[o], e);
                  if ((r.push(i), i.type === 'error')) break;
                }
                return r;
              })(t, this.socket.binaryType).forEach(function (t) {
                if (
                  (e.readyState === 'opening' && t.type === 'open' && e.onOpen(),
                    t.type === 'close')
                )
                  return e.onClose(), !1;
                e.onPacket(t);
              }),
                this.readyState !== 'closed' &&
                ((this.polling = !1),
                  this.emit('pollComplete'),
                  this.readyState === 'open' && this.poll());
            },
          },
          {
            key: 'doClose',
            value() {
              const t = this,
                e = function () {
                  t.write([{ type: 'close' }]);
                };
              this.readyState === 'open' ? e() : this.once('open', e);
            },
          },
          {
            key: 'write',
            value(t) {
              const e = this;
              (this.writable = !1),
                (function (t, e) {
                  let n = t.length,
                    r = new Array(n),
                    o = 0;
                  t.forEach(function (t, i) {
                    x(t, !1, function (t) {
                      (r[i] = t), ++o === n && e(r.join(V));
                    });
                  });
                })(t, function (t) {
                  e.doWrite(t, function () {
                    (e.writable = !0), e.emit('drain');
                  });
                });
            },
          },
          {
            key: 'uri',
            value() {
              let t = this.query || {},
                e = this.opts.secure ? 'https' : 'http',
                n = '';
              !1 !== this.opts.timestampRequests && (t[this.opts.timestampParam] = X()),
                this.supportsBinary || t.sid || (t.b64 = 1),
                this.opts.port &&
                ((e === 'https' && Number(this.opts.port) !== 443) ||
                  (e === 'http' && Number(this.opts.port) !== 80)) &&
                (n = `:${this.opts.port}`);
              const r = G.encode(t);
              return `${e}://${this.opts.hostname.indexOf(':') !== -1
                  ? `[${this.opts.hostname}]`
                  : this.opts.hostname
                }${n}${this.opts.path}${r.length ? `?${r}` : ''}`;
            },
          },
        ]),
        o
      );
    })(H);
  function Z() { }
  var tt = new b({ xdomain: !1 }).responseType != null,
    et = (function (t) {
      i(s, t);
      const n = h(s);
      function s(t) {
        let r;
        if ((e(this, s), (r = n.call(this, t)), typeof location !== 'undefined')) {
          let o = location.protocol === 'https:',
            i = location.port;
          i || (i = o ? '443' : '80'),
            (r.xd =
              (typeof location !== 'undefined' && t.hostname !== location.hostname) ||
              i !== t.port),
            (r.xs = t.secure !== o);
        }
        const a = t && t.forceBase64;
        return (r.supportsBinary = tt && !a), r;
      }
      return (
        r(s, [
          {
            key: 'request',
            value() {
              const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
              return o(t, { xd: this.xd, xs: this.xs }, this.opts), new nt(this.uri(), t);
            },
          },
          {
            key: 'doWrite',
            value(t, e) {
              const n = this,
                r = this.request({ method: 'POST', data: t });
              r.on('success', e),
                r.on('error', function (t) {
                  n.onError('xhr post error', t);
                });
            },
          },
          {
            key: 'doPoll',
            value() {
              const t = this,
                e = this.request();
              e.on('data', this.onData.bind(this)),
                e.on('error', function (e) {
                  t.onError('xhr poll error', e);
                }),
                (this.pollXhr = e);
            },
          },
        ]),
        s
      );
    })(Q),
    nt = (function (t) {
      i(o, t);
      const n = h(o);
      function o(t, r) {
        let i;
        return (
          e(this, o),
          A(c((i = n.call(this))), r),
          (i.opts = r),
          (i.method = r.method || 'GET'),
          (i.uri = t),
          (i.async = !1 !== r.async),
          (i.data = void 0 !== r.data ? r.data : null),
          i.create(),
          i
        );
      }
      return (
        r(o, [
          {
            key: 'create',
            value() {
              const t = this,
                e = w(
                  this.opts,
                  'agent',
                  'pfx',
                  'key',
                  'passphrase',
                  'cert',
                  'ca',
                  'ciphers',
                  'rejectUnauthorized',
                  'autoUnref'
                );
              (e.xdomain = !!this.opts.xd), (e.xscheme = !!this.opts.xs);
              const n = (this.xhr = new b(e));
              try {
                n.open(this.method, this.uri, this.async);
                try {
                  if (this.opts.extraHeaders)
                    for (const r in (n.setDisableHeaderCheck && n.setDisableHeaderCheck(!0),
                      this.opts.extraHeaders))
                      this.opts.extraHeaders.hasOwnProperty(r) &&
                        n.setRequestHeader(r, this.opts.extraHeaders[r]);
                } catch (t) { }
                if (this.method === 'POST')
                  try {
                    n.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
                  } catch (t) { }
                try {
                  n.setRequestHeader('Accept', '*/*');
                } catch (t) { }
                'withCredentials' in n && (n.withCredentials = this.opts.withCredentials),
                  this.opts.requestTimeout && (n.timeout = this.opts.requestTimeout),
                  (n.onreadystatechange = function () {
                    n.readyState === 4 &&
                      (n.status === 200 || n.status === 1223
                        ? t.onLoad()
                        : t.setTimeoutFn(function () {
                          t.onError(typeof n.status === 'number' ? n.status : 0);
                        }, 0));
                  }),
                  n.send(this.data);
              } catch (e) {
                return void this.setTimeoutFn(function () {
                  t.onError(e);
                }, 0);
              }
              typeof document !== 'undefined' &&
                ((this.index = o.requestsCount++), (o.requests[this.index] = this));
            },
          },
          {
            key: 'onSuccess',
            value() {
              this.emit('success'), this.cleanup();
            },
          },
          {
            key: 'onData',
            value(t) {
              this.emit('data', t), this.onSuccess();
            },
          },
          {
            key: 'onError',
            value(t) {
              this.emit('error', t), this.cleanup(!0);
            },
          },
          {
            key: 'cleanup',
            value(t) {
              if (void 0 !== this.xhr && this.xhr !== null) {
                if (((this.xhr.onreadystatechange = Z), t))
                  try {
                    this.xhr.abort();
                  } catch (t) { }
                typeof document !== 'undefined' && delete o.requests[this.index], (this.xhr = null);
              }
            },
          },
          {
            key: 'onLoad',
            value() {
              const t = this.xhr.responseText;
              t !== null && this.onData(t);
            },
          },
          {
            key: 'abort',
            value() {
              this.cleanup();
            },
          },
        ]),
        o
      );
    })(R);
  if (((nt.requestsCount = 0), (nt.requests = {}), typeof document !== 'undefined'))
    if (typeof attachEvent === 'function') attachEvent('onunload', rt);
    else if (typeof addEventListener === 'function') {
      addEventListener('onpagehide' in k ? 'pagehide' : 'unload', rt, !1);
    }
  function rt() {
    for (const t in nt.requests) nt.requests.hasOwnProperty(t) && nt.requests[t].abort();
  }
  const ot =
    typeof Promise === 'function' && typeof Promise.resolve === 'function'
      ? function (t) {
        return Promise.resolve().then(t);
      }
      : function (t, e) {
        return e(t, 0);
      },
    it = k.WebSocket || k.MozWebSocket,
    st =
      typeof navigator !== 'undefined' &&
      typeof navigator.product === 'string' &&
      navigator.product.toLowerCase() === 'reactnative',
    at = (function (t) {
      i(o, t);
      const n = h(o);
      function o(t) {
        let r;
        return e(this, o), ((r = n.call(this, t)).supportsBinary = !t.forceBase64), r;
      }
      return (
        r(o, [
          {
            key: 'name',
            get() {
              return 'websocket';
            },
          },
          {
            key: 'doOpen',
            value() {
              if (this.check()) {
                const t = this.uri(),
                  e = this.opts.protocols,
                  n = st
                    ? {}
                    : w(
                      this.opts,
                      'agent',
                      'perMessageDeflate',
                      'pfx',
                      'key',
                      'passphrase',
                      'cert',
                      'ca',
                      'ciphers',
                      'rejectUnauthorized',
                      'localAddress',
                      'protocolVersion',
                      'origin',
                      'maxPayload',
                      'family',
                      'checkServerIdentity'
                    );
                this.opts.extraHeaders && (n.headers = this.opts.extraHeaders);
                try {
                  this.ws = st ? new it(t, e, n) : e ? new it(t, e) : new it(t);
                } catch (t) {
                  return this.emit('error', t);
                }
                (this.ws.binaryType = this.socket.binaryType || 'arraybuffer'),
                  this.addEventListeners();
              }
            },
          },
          {
            key: 'addEventListeners',
            value() {
              const t = this;
              (this.ws.onopen = function () {
                t.opts.autoUnref && t.ws._socket.unref(), t.onOpen();
              }),
                (this.ws.onclose = this.onClose.bind(this)),
                (this.ws.onmessage = function (e) {
                  return t.onData(e.data);
                }),
                (this.ws.onerror = function (e) {
                  return t.onError('websocket error', e);
                });
            },
          },
          {
            key: 'write',
            value(t) {
              const e = this;
              this.writable = !1;
              for (
                let n = function (n) {
                  const r = t[n],
                    o = n === t.length - 1;
                  x(r, e.supportsBinary, function (t) {
                    try {
                      e.ws.send(t);
                    } catch (t) { }
                    o &&
                      ot(function () {
                        (e.writable = !0), e.emit('drain');
                      }, e.setTimeoutFn);
                  });
                },
                r = 0;
                r < t.length;
                r++
              )
                n(r);
            },
          },
          {
            key: 'doClose',
            value() {
              void 0 !== this.ws && (this.ws.close(), (this.ws = null));
            },
          },
          {
            key: 'uri',
            value() {
              let t = this.query || {},
                e = this.opts.secure ? 'wss' : 'ws',
                n = '';
              this.opts.port &&
                ((e === 'wss' && Number(this.opts.port) !== 443) ||
                  (e === 'ws' && Number(this.opts.port) !== 80)) &&
                (n = `:${this.opts.port}`),
                this.opts.timestampRequests && (t[this.opts.timestampParam] = X()),
                this.supportsBinary || (t.b64 = 1);
              const r = G.encode(t);
              return `${e}://${this.opts.hostname.indexOf(':') !== -1
                  ? `[${this.opts.hostname}]`
                  : this.opts.hostname
                }${n}${this.opts.path}${r.length ? `?${r}` : ''}`;
            },
          },
          {
            key: 'check',
            value() {
              return !(!it || ('__initialize' in it && this.name === o.prototype.name));
            },
          },
        ]),
        o
      );
    })(H),
    ct = { websocket: at, polling: et },
    ut = (function (n) {
      i(a, n);
      const s = h(a);
      function a(n) {
        let r,
          i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return (
          e(this, a),
          (r = s.call(this)),
          n && t(n) === 'object' && ((i = n), (n = null)),
          n
            ? ((n = v(n)),
              (i.hostname = n.host),
              (i.secure = n.protocol === 'https' || n.protocol === 'wss'),
              (i.port = n.port),
              n.query && (i.query = n.query))
            : i.host && (i.hostname = v(i.host).host),
          A(c(r), i),
          (r.secure =
            i.secure != null
              ? i.secure
              : typeof location !== 'undefined' && location.protocol === 'https:'),
          i.hostname && !i.port && (i.port = r.secure ? '443' : '80'),
          (r.hostname =
            i.hostname || (typeof location !== 'undefined' ? location.hostname : 'localhost')),
          (r.port =
            i.port ||
            (typeof location !== 'undefined' && location.port
              ? location.port
              : r.secure
                ? '443'
                : '80')),
          (r.transports = i.transports || ['polling', 'websocket']),
          (r.readyState = ''),
          (r.writeBuffer = []),
          (r.prevBufferLen = 0),
          (r.opts = o(
            {
              path: '/engine.io',
              agent: !1,
              withCredentials: !1,
              upgrade: !0,
              timestampParam: 't',
              rememberUpgrade: !1,
              rejectUnauthorized: !0,
              perMessageDeflate: { threshold: 1024 },
              transportOptions: {},
              closeOnBeforeunload: !0,
            },
            i
          )),
          (r.opts.path = `${r.opts.path.replace(/\/$/, '')}/`),
          typeof r.opts.query === 'string' && (r.opts.query = G.decode(r.opts.query)),
          (r.id = null),
          (r.upgrades = null),
          (r.pingInterval = null),
          (r.pingTimeout = null),
          (r.pingTimeoutTimer = null),
          typeof addEventListener === 'function' &&
          (r.opts.closeOnBeforeunload &&
            addEventListener(
              'beforeunload',
              function () {
                r.transport && (r.transport.removeAllListeners(), r.transport.close());
              },
              !1
            ),
            r.hostname !== 'localhost' &&
            ((r.offlineEventListener = function () {
              r.onClose('transport close');
            }),
              addEventListener('offline', r.offlineEventListener, !1))),
          r.open(),
          r
        );
      }
      return (
        r(a, [
          {
            key: 'createTransport',
            value(t) {
              const e = (function (t) {
                const e = {};
                for (const n in t) t.hasOwnProperty(n) && (e[n] = t[n]);
                return e;
              })(this.opts.query);
              (e.EIO = 4), (e.transport = t), this.id && (e.sid = this.id);
              const n = o({}, this.opts.transportOptions[t], this.opts, {
                query: e,
                socket: this,
                hostname: this.hostname,
                secure: this.secure,
                port: this.port,
              });
              return new ct[t](n);
            },
          },
          {
            key: 'open',
            value() {
              let t,
                e = this;
              if (
                this.opts.rememberUpgrade &&
                a.priorWebsocketSuccess &&
                this.transports.indexOf('websocket') !== -1
              )
                t = 'websocket';
              else {
                if (this.transports.length === 0)
                  return void this.setTimeoutFn(function () {
                    e.emitReserved('error', 'No transports available');
                  }, 0);
                t = this.transports[0];
              }
              this.readyState = 'opening';
              try {
                t = this.createTransport(t);
              } catch (t) {
                return this.transports.shift(), void this.open();
              }
              t.open(), this.setTransport(t);
            },
          },
          {
            key: 'setTransport',
            value(t) {
              const e = this;
              this.transport && this.transport.removeAllListeners(),
                (this.transport = t),
                t
                  .on('drain', this.onDrain.bind(this))
                  .on('packet', this.onPacket.bind(this))
                  .on('error', this.onError.bind(this))
                  .on('close', function () {
                    e.onClose('transport close');
                  });
            },
          },
          {
            key: 'probe',
            value(t) {
              let e = this,
                n = this.createTransport(t),
                r = !1;
              a.priorWebsocketSuccess = !1;
              const o = function () {
                r ||
                  (n.send([{ type: 'ping', data: 'probe' }]),
                    n.once('packet', function (t) {
                      if (!r)
                        if (t.type === 'pong' && t.data === 'probe') {
                          if (((e.upgrading = !0), e.emitReserved('upgrading', n), !n)) return;
                          (a.priorWebsocketSuccess = n.name === 'websocket'),
                            e.transport.pause(function () {
                              r ||
                                (e.readyState !== 'closed' &&
                                  (f(),
                                    e.setTransport(n),
                                    n.send([{ type: 'upgrade' }]),
                                    e.emitReserved('upgrade', n),
                                    (n = null),
                                    (e.upgrading = !1),
                                    e.flush()));
                            });
                        } else {
                          const o = new Error('probe error');
                          (o.transport = n.name), e.emitReserved('upgradeError', o);
                        }
                    }));
              };
              function i() {
                r || ((r = !0), f(), n.close(), (n = null));
              }
              const s = function (t) {
                const r = new Error(`probe error: ${t}`);
                (r.transport = n.name), i(), e.emitReserved('upgradeError', r);
              };
              function c() {
                s('transport closed');
              }
              function u() {
                s('socket closed');
              }
              function h(t) {
                n && t.name !== n.name && i();
              }
              var f = function () {
                n.removeListener('open', o),
                  n.removeListener('error', s),
                  n.removeListener('close', c),
                  e.off('close', u),
                  e.off('upgrading', h);
              };
              n.once('open', o),
                n.once('error', s),
                n.once('close', c),
                this.once('close', u),
                this.once('upgrading', h),
                n.open();
            },
          },
          {
            key: 'onOpen',
            value() {
              if (
                ((this.readyState = 'open'),
                  (a.priorWebsocketSuccess = this.transport.name === 'websocket'),
                  this.emitReserved('open'),
                  this.flush(),
                  this.readyState === 'open' && this.opts.upgrade && this.transport.pause)
              )
                for (let t = 0, e = this.upgrades.length; t < e; t++) this.probe(this.upgrades[t]);
            },
          },
          {
            key: 'onPacket',
            value(t) {
              if (
                this.readyState === 'opening' ||
                this.readyState === 'open' ||
                this.readyState === 'closing'
              )
                switch ((this.emitReserved('packet', t), this.emitReserved('heartbeat'), t.type)) {
                  case 'open':
                    this.onHandshake(JSON.parse(t.data));
                    break;
                  case 'ping':
                    this.resetPingTimeout(),
                      this.sendPacket('pong'),
                      this.emitReserved('ping'),
                      this.emitReserved('pong');
                    break;
                  case 'error':
                    var e = new Error('server error');
                    (e.code = t.data), this.onError(e);
                    break;
                  case 'message':
                    this.emitReserved('data', t.data), this.emitReserved('message', t.data);
                }
            },
          },
          {
            key: 'onHandshake',
            value(t) {
              this.emitReserved('handshake', t),
                (this.id = t.sid),
                (this.transport.query.sid = t.sid),
                (this.upgrades = this.filterUpgrades(t.upgrades)),
                (this.pingInterval = t.pingInterval),
                (this.pingTimeout = t.pingTimeout),
                this.onOpen(),
                this.readyState !== 'closed' && this.resetPingTimeout();
            },
          },
          {
            key: 'resetPingTimeout',
            value() {
              const t = this;
              this.clearTimeoutFn(this.pingTimeoutTimer),
                (this.pingTimeoutTimer = this.setTimeoutFn(function () {
                  t.onClose('ping timeout');
                }, this.pingInterval + this.pingTimeout)),
                this.opts.autoUnref && this.pingTimeoutTimer.unref();
            },
          },
          {
            key: 'onDrain',
            value() {
              this.writeBuffer.splice(0, this.prevBufferLen),
                (this.prevBufferLen = 0),
                this.writeBuffer.length === 0 ? this.emitReserved('drain') : this.flush();
            },
          },
          {
            key: 'flush',
            value() {
              this.readyState !== 'closed' &&
                this.transport.writable &&
                !this.upgrading &&
                this.writeBuffer.length &&
                (this.transport.send(this.writeBuffer),
                  (this.prevBufferLen = this.writeBuffer.length),
                  this.emitReserved('flush'));
            },
          },
          {
            key: 'write',
            value(t, e, n) {
              return this.sendPacket('message', t, e, n), this;
            },
          },
          {
            key: 'send',
            value(t, e, n) {
              return this.sendPacket('message', t, e, n), this;
            },
          },
          {
            key: 'sendPacket',
            value(t, e, n, r) {
              if (
                (typeof e === 'function' && ((r = e), (e = void 0)),
                  typeof n === 'function' && ((r = n), (n = null)),
                  this.readyState !== 'closing' && this.readyState !== 'closed')
              ) {
                (n = n || {}).compress = !1 !== n.compress;
                const o = { type: t, data: e, options: n };
                this.emitReserved('packetCreate', o),
                  this.writeBuffer.push(o),
                  r && this.once('flush', r),
                  this.flush();
              }
            },
          },
          {
            key: 'close',
            value() {
              const t = this,
                e = function () {
                  t.onClose('forced close'), t.transport.close();
                },
                n = function n() {
                  t.off('upgrade', n), t.off('upgradeError', n), e();
                },
                r = function () {
                  t.once('upgrade', n), t.once('upgradeError', n);
                };
              return (
                (this.readyState !== 'opening' && this.readyState !== 'open') ||
                ((this.readyState = 'closing'),
                  this.writeBuffer.length
                    ? this.once('drain', function () {
                      t.upgrading ? r() : e();
                    })
                    : this.upgrading
                      ? r()
                      : e()),
                this
              );
            },
          },
          {
            key: 'onError',
            value(t) {
              (a.priorWebsocketSuccess = !1),
                this.emitReserved('error', t),
                this.onClose('transport error', t);
            },
          },
          {
            key: 'onClose',
            value(t, e) {
              (this.readyState !== 'opening' &&
                this.readyState !== 'open' &&
                this.readyState !== 'closing') ||
                (this.clearTimeoutFn(this.pingTimeoutTimer),
                  this.transport.removeAllListeners('close'),
                  this.transport.close(),
                  this.transport.removeAllListeners(),
                  typeof removeEventListener === 'function' &&
                  removeEventListener('offline', this.offlineEventListener, !1),
                  (this.readyState = 'closed'),
                  (this.id = null),
                  this.emitReserved('close', t, e),
                  (this.writeBuffer = []),
                  (this.prevBufferLen = 0));
            },
          },
          {
            key: 'filterUpgrades',
            value(t) {
              for (var e = [], n = 0, r = t.length; n < r; n++)
                ~this.transports.indexOf(t[n]) && e.push(t[n]);
              return e;
            },
          },
        ]),
        a
      );
    })(R);
  ut.protocol = 4;
  const ht = typeof ArrayBuffer === 'function',
    ft = Object.prototype.toString,
    lt =
      typeof Blob === 'function' ||
      (typeof Blob !== 'undefined' && ft.call(Blob) === '[object BlobConstructor]'),
    pt =
      typeof File === 'function' ||
      (typeof File !== 'undefined' && ft.call(File) === '[object FileConstructor]');
  function dt(t) {
    return (
      (ht &&
        (t instanceof ArrayBuffer ||
          (function (t) {
            return typeof ArrayBuffer.isView === 'function'
              ? ArrayBuffer.isView(t)
              : t.buffer instanceof ArrayBuffer;
          })(t))) ||
      (lt && t instanceof Blob) ||
      (pt && t instanceof File)
    );
  }
  function yt(e, n) {
    if (!e || t(e) !== 'object') return !1;
    if (Array.isArray(e)) {
      for (let r = 0, o = e.length; r < o; r++) if (yt(e[r])) return !0;
      return !1;
    }
    if (dt(e)) return !0;
    if (e.toJSON && typeof e.toJSON === 'function' && arguments.length === 1)
      return yt(e.toJSON(), !0);
    for (const i in e) if (Object.prototype.hasOwnProperty.call(e, i) && yt(e[i])) return !0;
    return !1;
  }
  function vt(t) {
    const e = [],
      n = t.data,
      r = t;
    return (r.data = mt(n, e)), (r.attachments = e.length), { packet: r, buffers: e };
  }
  function mt(e, n) {
    if (!e) return e;
    if (dt(e)) {
      const r = { _placeholder: !0, num: n.length };
      return n.push(e), r;
    }
    if (Array.isArray(e)) {
      for (var o = new Array(e.length), i = 0; i < e.length; i++) o[i] = mt(e[i], n);
      return o;
    }
    if (t(e) === 'object' && !(e instanceof Date)) {
      const s = {};
      for (const a in e) e.hasOwnProperty(a) && (s[a] = mt(e[a], n));
      return s;
    }
    return e;
  }
  function gt(t, e) {
    return (t.data = kt(t.data, e)), (t.attachments = void 0), t;
  }
  function kt(e, n) {
    if (!e) return e;
    if (e && e._placeholder) return n[e.num];
    if (Array.isArray(e)) for (let r = 0; r < e.length; r++) e[r] = kt(e[r], n);
    else if (t(e) === 'object') for (const o in e) e.hasOwnProperty(o) && (e[o] = kt(e[o], n));
    return e;
  }
  let bt;
  !(function (t) {
    (t[(t.CONNECT = 0)] = 'CONNECT'),
      (t[(t.DISCONNECT = 1)] = 'DISCONNECT'),
      (t[(t.EVENT = 2)] = 'EVENT'),
      (t[(t.ACK = 3)] = 'ACK'),
      (t[(t.CONNECT_ERROR = 4)] = 'CONNECT_ERROR'),
      (t[(t.BINARY_EVENT = 5)] = 'BINARY_EVENT'),
      (t[(t.BINARY_ACK = 6)] = 'BINARY_ACK');
  })(bt || (bt = {}));
  const wt = (function () {
    function t() {
      e(this, t);
    }
    return (
      r(t, [
        {
          key: 'encode',
          value(t) {
            return (t.type !== bt.EVENT && t.type !== bt.ACK) || !yt(t)
              ? [this.encodeAsString(t)]
              : ((t.type = t.type === bt.EVENT ? bt.BINARY_EVENT : bt.BINARY_ACK),
                this.encodeAsBinary(t));
          },
        },
        {
          key: 'encodeAsString',
          value(t) {
            let e = `${t.type}`;
            return (
              (t.type !== bt.BINARY_EVENT && t.type !== bt.BINARY_ACK) ||
              (e += `${t.attachments}-`),
              t.nsp && t.nsp !== '/' && (e += `${t.nsp},`),
              t.id != null && (e += t.id),
              t.data != null && (e += JSON.stringify(t.data)),
              e
            );
          },
        },
        {
          key: 'encodeAsBinary',
          value(t) {
            const e = vt(t),
              n = this.encodeAsString(e.packet),
              r = e.buffers;
            return r.unshift(n), r;
          },
        },
      ]),
      t
    );
  })(),
    _t = (function (n) {
      i(a, n);
      const o = h(a);
      function a() {
        return e(this, a), o.call(this);
      }
      return (
        r(
          a,
          [
            {
              key: 'add',
              value(t) {
                let e;
                if (typeof t === 'string')
                  (e = this.decodeString(t)).type === bt.BINARY_EVENT || e.type === bt.BINARY_ACK
                    ? ((this.reconstructor = new Et(e)),
                      e.attachments === 0 &&
                      f(s(a.prototype), 'emitReserved', this).call(this, 'decoded', e))
                    : f(s(a.prototype), 'emitReserved', this).call(this, 'decoded', e);
                else {
                  if (!dt(t) && !t.base64) throw new Error(`Unknown type: ${t}`);
                  if (!this.reconstructor)
                    throw new Error('got binary data when not reconstructing a packet');
                  (e = this.reconstructor.takeBinaryData(t)) &&
                    ((this.reconstructor = null),
                      f(s(a.prototype), 'emitReserved', this).call(this, 'decoded', e));
                }
              },
            },
            {
              key: 'decodeString',
              value(t) {
                let e = 0,
                  n = { type: Number(t.charAt(0)) };
                if (void 0 === bt[n.type]) throw new Error(`unknown packet type ${n.type}`);
                if (n.type === bt.BINARY_EVENT || n.type === bt.BINARY_ACK) {
                  for (var r = e + 1; t.charAt(++e) !== '-' && e != t.length;);
                  const o = t.substring(r, e);
                  if (o != Number(o) || t.charAt(e) !== '-') throw new Error('Illegal attachments');
                  n.attachments = Number(o);
                }
                if (t.charAt(e + 1) === '/') {
                  for (var i = e + 1; ++e;) {
                    if (t.charAt(e) === ',') break;
                    if (e === t.length) break;
                  }
                  n.nsp = t.substring(i, e);
                } else n.nsp = '/';
                const s = t.charAt(e + 1);
                if (s !== '' && Number(s) == s) {
                  for (var c = e + 1; ++e;) {
                    const u = t.charAt(e);
                    if (u == null || Number(u) != u) {
                      --e;
                      break;
                    }
                    if (e === t.length) break;
                  }
                  n.id = Number(t.substring(c, e + 1));
                }
                if (t.charAt(++e)) {
                  const h = (function (t) {
                    try {
                      return JSON.parse(t);
                    } catch (t) {
                      return !1;
                    }
                  })(t.substr(e));
                  if (!a.isPayloadValid(n.type, h)) throw new Error('invalid payload');
                  n.data = h;
                }
                return n;
              },
            },
            {
              key: 'destroy',
              value() {
                this.reconstructor && this.reconstructor.finishedReconstruction();
              },
            },
          ],
          [
            {
              key: 'isPayloadValid',
              value(e, n) {
                switch (e) {
                  case bt.CONNECT:
                    return t(n) === 'object';
                  case bt.DISCONNECT:
                    return void 0 === n;
                  case bt.CONNECT_ERROR:
                    return typeof n === 'string' || t(n) === 'object';
                  case bt.EVENT:
                  case bt.BINARY_EVENT:
                    return Array.isArray(n) && n.length > 0;
                  case bt.ACK:
                  case bt.BINARY_ACK:
                    return Array.isArray(n);
                }
              },
            },
          ]
        ),
        a
      );
    })(R);
  var Et = (function () {
    function t(n) {
      e(this, t), (this.packet = n), (this.buffers = []), (this.reconPack = n);
    }
    return (
      r(t, [
        {
          key: 'takeBinaryData',
          value(t) {
            if ((this.buffers.push(t), this.buffers.length === this.reconPack.attachments)) {
              const e = gt(this.reconPack, this.buffers);
              return this.finishedReconstruction(), e;
            }
            return null;
          },
        },
        {
          key: 'finishedReconstruction',
          value() {
            (this.reconPack = null), (this.buffers = []);
          },
        },
      ]),
      t
    );
  })(),
    At = Object.freeze({
      __proto__: null,
      protocol: 5,
      get PacketType() {
        return bt;
      },
      Encoder: wt,
      Decoder: _t,
    });
  function Rt(t, e, n) {
    return (
      t.on(e, n),
      function () {
        t.off(e, n);
      }
    );
  }
  const Tt = Object.freeze({
    connect: 1,
    connect_error: 1,
    disconnect: 1,
    disconnecting: 1,
    newListener: 1,
    removeListener: 1,
  }),
    Ct = (function (t) {
      i(o, t);
      const n = h(o);
      function o(t, r, i) {
        let s;
        return (
          e(this, o),
          ((s = n.call(this)).connected = !1),
          (s.disconnected = !0),
          (s.receiveBuffer = []),
          (s.sendBuffer = []),
          (s.ids = 0),
          (s.acks = {}),
          (s.flags = {}),
          (s.io = t),
          (s.nsp = r),
          i && i.auth && (s.auth = i.auth),
          s.io._autoConnect && s.open(),
          s
        );
      }
      return (
        r(o, [
          {
            key: 'subEvents',
            value() {
              if (!this.subs) {
                const t = this.io;
                this.subs = [
                  Rt(t, 'open', this.onopen.bind(this)),
                  Rt(t, 'packet', this.onpacket.bind(this)),
                  Rt(t, 'error', this.onerror.bind(this)),
                  Rt(t, 'close', this.onclose.bind(this)),
                ];
              }
            },
          },
          {
            key: 'active',
            get() {
              return !!this.subs;
            },
          },
          {
            key: 'connect',
            value() {
              return (
                this.connected ||
                (this.subEvents(),
                  this.io._reconnecting || this.io.open(),
                  this.io._readyState === 'open' && this.onopen()),
                this
              );
            },
          },
          {
            key: 'open',
            value() {
              return this.connect();
            },
          },
          {
            key: 'send',
            value() {
              for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
                e[n] = arguments[n];
              return e.unshift('message'), this.emit.apply(this, e), this;
            },
          },
          {
            key: 'emit',
            value(t) {
              if (Tt.hasOwnProperty(t)) throw new Error(`"${t}" is a reserved event name`);
              for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
                n[r - 1] = arguments[r];
              n.unshift(t);
              const o = { type: bt.EVENT, data: n, options: {} };
              if (
                ((o.options.compress = !1 !== this.flags.compress),
                  typeof n[n.length - 1] === 'function')
              ) {
                const i = this.ids++,
                  s = n.pop();
                this._registerAckCallback(i, s), (o.id = i);
              }
              const a =
                this.io.engine && this.io.engine.transport && this.io.engine.transport.writable,
                c = this.flags.volatile && (!a || !this.connected);
              return (
                c || (this.connected ? this.packet(o) : this.sendBuffer.push(o)),
                (this.flags = {}),
                this
              );
            },
          },
          {
            key: '_registerAckCallback',
            value(t, e) {
              const n = this,
                r = this.flags.timeout;
              if (void 0 !== r) {
                const o = this.io.setTimeoutFn(function () {
                  delete n.acks[t];
                  for (let r = 0; r < n.sendBuffer.length; r++)
                    n.sendBuffer[r].id === t && n.sendBuffer.splice(r, 1);
                  e.call(n, new Error('operation has timed out'));
                }, r);
                this.acks[t] = function () {
                  n.io.clearTimeoutFn(o);
                  for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
                    r[i] = arguments[i];
                  e.apply(n, [null].concat(r));
                };
              } else this.acks[t] = e;
            },
          },
          {
            key: 'packet',
            value(t) {
              (t.nsp = this.nsp), this.io._packet(t);
            },
          },
          {
            key: 'onopen',
            value() {
              const t = this;
              typeof this.auth === 'function'
                ? this.auth(function (e) {
                  t.packet({ type: bt.CONNECT, data: e });
                })
                : this.packet({ type: bt.CONNECT, data: this.auth });
            },
          },
          {
            key: 'onerror',
            value(t) {
              this.connected || this.emitReserved('connect_error', t);
            },
          },
          {
            key: 'onclose',
            value(t) {
              (this.connected = !1),
                (this.disconnected = !0),
                delete this.id,
                this.emitReserved('disconnect', t);
            },
          },
          {
            key: 'onpacket',
            value(t) {
              if (t.nsp === this.nsp)
                switch (t.type) {
                  case bt.CONNECT:
                    if (t.data && t.data.sid) {
                      const e = t.data.sid;
                      this.onconnect(e);
                    } else
                      this.emitReserved(
                        'connect_error',
                        new Error(
                          'It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)'
                        )
                      );
                    break;
                  case bt.EVENT:
                  case bt.BINARY_EVENT:
                    this.onevent(t);
                    break;
                  case bt.ACK:
                  case bt.BINARY_ACK:
                    this.onack(t);
                    break;
                  case bt.DISCONNECT:
                    this.ondisconnect();
                    break;
                  case bt.CONNECT_ERROR:
                    this.destroy();
                    var n = new Error(t.data.message);
                    (n.data = t.data.data), this.emitReserved('connect_error', n);
                }
            },
          },
          {
            key: 'onevent',
            value(t) {
              const e = t.data || [];
              t.id != null && e.push(this.ack(t.id)),
                this.connected ? this.emitEvent(e) : this.receiveBuffer.push(Object.freeze(e));
            },
          },
          {
            key: 'emitEvent',
            value(t) {
              if (this._anyListeners && this._anyListeners.length) {
                let e,
                  n = p(this._anyListeners.slice());
                try {
                  for (n.s(); !(e = n.n()).done;) {
                    e.value.apply(this, t);
                  }
                } catch (t) {
                  n.e(t);
                } finally {
                  n.f();
                }
              }
              f(s(o.prototype), 'emit', this).apply(this, t);
            },
          },
          {
            key: 'ack',
            value(t) {
              let e = this,
                n = !1;
              return function () {
                if (!n) {
                  n = !0;
                  for (var r = arguments.length, o = new Array(r), i = 0; i < r; i++)
                    o[i] = arguments[i];
                  e.packet({ type: bt.ACK, id: t, data: o });
                }
              };
            },
          },
          {
            key: 'onack',
            value(t) {
              const e = this.acks[t.id];
              typeof e === 'function' && (e.apply(this, t.data), delete this.acks[t.id]);
            },
          },
          {
            key: 'onconnect',
            value(t) {
              (this.id = t),
                (this.connected = !0),
                (this.disconnected = !1),
                this.emitBuffered(),
                this.emitReserved('connect');
            },
          },
          {
            key: 'emitBuffered',
            value() {
              const t = this;
              this.receiveBuffer.forEach(function (e) {
                return t.emitEvent(e);
              }),
                (this.receiveBuffer = []),
                this.sendBuffer.forEach(function (e) {
                  return t.packet(e);
                }),
                (this.sendBuffer = []);
            },
          },
          {
            key: 'ondisconnect',
            value() {
              this.destroy(), this.onclose('io server disconnect');
            },
          },
          {
            key: 'destroy',
            value() {
              this.subs &&
                (this.subs.forEach(function (t) {
                  return t();
                }),
                  (this.subs = void 0)),
                this.io._destroy(this);
            },
          },
          {
            key: 'disconnect',
            value() {
              return (
                this.connected && this.packet({ type: bt.DISCONNECT }),
                this.destroy(),
                this.connected && this.onclose('io client disconnect'),
                this
              );
            },
          },
          {
            key: 'close',
            value() {
              return this.disconnect();
            },
          },
          {
            key: 'compress',
            value(t) {
              return (this.flags.compress = t), this;
            },
          },
          {
            key: 'volatile',
            get() {
              return (this.flags.volatile = !0), this;
            },
          },
          {
            key: 'timeout',
            value(t) {
              return (this.flags.timeout = t), this;
            },
          },
          {
            key: 'onAny',
            value(t) {
              return (
                (this._anyListeners = this._anyListeners || []), this._anyListeners.push(t), this
              );
            },
          },
          {
            key: 'prependAny',
            value(t) {
              return (
                (this._anyListeners = this._anyListeners || []), this._anyListeners.unshift(t), this
              );
            },
          },
          {
            key: 'offAny',
            value(t) {
              if (!this._anyListeners) return this;
              if (t) {
                for (let e = this._anyListeners, n = 0; n < e.length; n++)
                  if (t === e[n]) return e.splice(n, 1), this;
              } else this._anyListeners = [];
              return this;
            },
          },
          {
            key: 'listenersAny',
            value() {
              return this._anyListeners || [];
            },
          },
        ]),
        o
      );
    })(R),
    Ot = St;
  function St(t) {
    (t = t || {}),
      (this.ms = t.min || 100),
      (this.max = t.max || 1e4),
      (this.factor = t.factor || 2),
      (this.jitter = t.jitter > 0 && t.jitter <= 1 ? t.jitter : 0),
      (this.attempts = 0);
  }
  (St.prototype.duration = function () {
    let t = this.ms * Math.pow(this.factor, this.attempts++);
    if (this.jitter) {
      const e = Math.random(),
        n = Math.floor(e * this.jitter * t);
      t = (1 & Math.floor(10 * e)) == 0 ? t - n : t + n;
    }
    return 0 | Math.min(t, this.max);
  }),
    (St.prototype.reset = function () {
      this.attempts = 0;
    }),
    (St.prototype.setMin = function (t) {
      this.ms = t;
    }),
    (St.prototype.setMax = function (t) {
      this.max = t;
    }),
    (St.prototype.setJitter = function (t) {
      this.jitter = t;
    });
  const Bt = (function (n) {
    i(s, n);
    const o = h(s);
    function s(n, r) {
      let i, a;
      e(this, s),
        ((i = o.call(this)).nsps = {}),
        (i.subs = []),
        n && t(n) === 'object' && ((r = n), (n = void 0)),
        ((r = r || {}).path = r.path || '/socket.io'),
        (i.opts = r),
        A(c(i), r),
        i.reconnection(!1 !== r.reconnection),
        i.reconnectionAttempts(r.reconnectionAttempts || 1 / 0),
        i.reconnectionDelay(r.reconnectionDelay || 1e3),
        i.reconnectionDelayMax(r.reconnectionDelayMax || 5e3),
        i.randomizationFactor((a = r.randomizationFactor) !== null && void 0 !== a ? a : 0.5),
        (i.backoff = new Ot({
          min: i.reconnectionDelay(),
          max: i.reconnectionDelayMax(),
          jitter: i.randomizationFactor(),
        })),
        i.timeout(r.timeout == null ? 2e4 : r.timeout),
        (i._readyState = 'closed'),
        (i.uri = n);
      const u = r.parser || At;
      return (
        (i.encoder = new u.Encoder()),
        (i.decoder = new u.Decoder()),
        (i._autoConnect = !1 !== r.autoConnect),
        i._autoConnect && i.open(),
        i
      );
    }
    return (
      r(s, [
        {
          key: 'reconnection',
          value(t) {
            return arguments.length ? ((this._reconnection = !!t), this) : this._reconnection;
          },
        },
        {
          key: 'reconnectionAttempts',
          value(t) {
            return void 0 === t
              ? this._reconnectionAttempts
              : ((this._reconnectionAttempts = t), this);
          },
        },
        {
          key: 'reconnectionDelay',
          value(t) {
            let e;
            return void 0 === t
              ? this._reconnectionDelay
              : ((this._reconnectionDelay = t),
                (e = this.backoff) === null || void 0 === e || e.setMin(t),
                this);
          },
        },
        {
          key: 'randomizationFactor',
          value(t) {
            let e;
            return void 0 === t
              ? this._randomizationFactor
              : ((this._randomizationFactor = t),
                (e = this.backoff) === null || void 0 === e || e.setJitter(t),
                this);
          },
        },
        {
          key: 'reconnectionDelayMax',
          value(t) {
            let e;
            return void 0 === t
              ? this._reconnectionDelayMax
              : ((this._reconnectionDelayMax = t),
                (e = this.backoff) === null || void 0 === e || e.setMax(t),
                this);
          },
        },
        {
          key: 'timeout',
          value(t) {
            return arguments.length ? ((this._timeout = t), this) : this._timeout;
          },
        },
        {
          key: 'maybeReconnectOnOpen',
          value() {
            !this._reconnecting &&
              this._reconnection &&
              this.backoff.attempts === 0 &&
              this.reconnect();
          },
        },
        {
          key: 'open',
          value(t) {
            const e = this;
            if (~this._readyState.indexOf('open')) return this;
            this.engine = new ut(this.uri, this.opts);
            const n = this.engine,
              r = this;
            (this._readyState = 'opening'), (this.skipReconnect = !1);
            const o = Rt(n, 'open', function () {
              r.onopen(), t && t();
            }),
              i = Rt(n, 'error', function (n) {
                r.cleanup(),
                  (r._readyState = 'closed'),
                  e.emitReserved('error', n),
                  t ? t(n) : r.maybeReconnectOnOpen();
              });
            if (!1 !== this._timeout) {
              const s = this._timeout;
              s === 0 && o();
              const a = this.setTimeoutFn(function () {
                o(), n.close(), n.emit('error', new Error('timeout'));
              }, s);
              this.opts.autoUnref && a.unref(),
                this.subs.push(function () {
                  clearTimeout(a);
                });
            }
            return this.subs.push(o), this.subs.push(i), this;
          },
        },
        {
          key: 'connect',
          value(t) {
            return this.open(t);
          },
        },
        {
          key: 'onopen',
          value() {
            this.cleanup(), (this._readyState = 'open'), this.emitReserved('open');
            const t = this.engine;
            this.subs.push(
              Rt(t, 'ping', this.onping.bind(this)),
              Rt(t, 'data', this.ondata.bind(this)),
              Rt(t, 'error', this.onerror.bind(this)),
              Rt(t, 'close', this.onclose.bind(this)),
              Rt(this.decoder, 'decoded', this.ondecoded.bind(this))
            );
          },
        },
        {
          key: 'onping',
          value() {
            this.emitReserved('ping');
          },
        },
        {
          key: 'ondata',
          value(t) {
            this.decoder.add(t);
          },
        },
        {
          key: 'ondecoded',
          value(t) {
            this.emitReserved('packet', t);
          },
        },
        {
          key: 'onerror',
          value(t) {
            this.emitReserved('error', t);
          },
        },
        {
          key: 'socket',
          value(t, e) {
            let n = this.nsps[t];
            return n || ((n = new Ct(this, t, e)), (this.nsps[t] = n)), n;
          },
        },
        {
          key: '_destroy',
          value(t) {
            for (let e = 0, n = Object.keys(this.nsps); e < n.length; e++) {
              const r = n[e];
              if (this.nsps[r].active) return;
            }
            this._close();
          },
        },
        {
          key: '_packet',
          value(t) {
            for (let e = this.encoder.encode(t), n = 0; n < e.length; n++)
              this.engine.write(e[n], t.options);
          },
        },
        {
          key: 'cleanup',
          value() {
            this.subs.forEach(function (t) {
              return t();
            }),
              (this.subs.length = 0),
              this.decoder.destroy();
          },
        },
        {
          key: '_close',
          value() {
            (this.skipReconnect = !0),
              (this._reconnecting = !1),
              this.onclose('forced close'),
              this.engine && this.engine.close();
          },
        },
        {
          key: 'disconnect',
          value() {
            return this._close();
          },
        },
        {
          key: 'onclose',
          value(t) {
            this.cleanup(),
              this.backoff.reset(),
              (this._readyState = 'closed'),
              this.emitReserved('close', t),
              this._reconnection && !this.skipReconnect && this.reconnect();
          },
        },
        {
          key: 'reconnect',
          value() {
            const t = this;
            if (this._reconnecting || this.skipReconnect) return this;
            const e = this;
            if (this.backoff.attempts >= this._reconnectionAttempts)
              this.backoff.reset(),
                this.emitReserved('reconnect_failed'),
                (this._reconnecting = !1);
            else {
              const n = this.backoff.duration();
              this._reconnecting = !0;
              const r = this.setTimeoutFn(function () {
                e.skipReconnect ||
                  (t.emitReserved('reconnect_attempt', e.backoff.attempts),
                    e.skipReconnect ||
                    e.open(function (n) {
                      n
                        ? ((e._reconnecting = !1),
                          e.reconnect(),
                          t.emitReserved('reconnect_error', n))
                        : e.onreconnect();
                    }));
              }, n);
              this.opts.autoUnref && r.unref(),
                this.subs.push(function () {
                  clearTimeout(r);
                });
            }
          },
        },
        {
          key: 'onreconnect',
          value() {
            const t = this.backoff.attempts;
            (this._reconnecting = !1), this.backoff.reset(), this.emitReserved('reconnect', t);
          },
        },
      ]),
      s
    );
  })(R),
    Nt = {};
  function xt(e, n) {
    t(e) === 'object' && ((n = e), (e = void 0));
    let r,
      o = (function (t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : '',
          n = arguments.length > 2 ? arguments[2] : void 0,
          r = t;
        (n = n || (typeof location !== 'undefined' && location)),
          t == null && (t = `${n.protocol}//${n.host}`),
          typeof t === 'string' &&
          (t.charAt(0) === '/' && (t = t.charAt(1) === '/' ? n.protocol + t : n.host + t),
            /^(https?|wss?):\/\//.test(t) ||
            (t = void 0 !== n ? `${n.protocol}//${t}` : `https://${t}`),
            (r = v(t))),
          r.port ||
          (/^(http|ws)$/.test(r.protocol)
            ? (r.port = '80')
            : /^(http|ws)s$/.test(r.protocol) && (r.port = '443')),
          (r.path = r.path || '/');
        const o = r.host.indexOf(':') !== -1 ? `[${r.host}]` : r.host;
        return (
          (r.id = `${r.protocol}://${o}:${r.port}${e}`),
          (r.href = `${r.protocol}://${o}${n && n.port === r.port ? '' : `:${r.port}`}`),
          r
        );
      })(e, (n = n || {}).path || '/socket.io'),
      i = o.source,
      s = o.id,
      a = o.path,
      c = Nt[s] && a in Nt[s].nsps;
    return (
      n.forceNew || n['force new connection'] || !1 === n.multiplex || c
        ? (r = new Bt(i, n))
        : (Nt[s] || (Nt[s] = new Bt(i, n)), (r = Nt[s])),
      o.query && !n.query && (n.query = o.queryKey),
      r.socket(o.path, n)
    );
  }
  return o(xt, { Manager: Bt, Socket: Ct, io: xt, connect: xt }), xt;
});
// # sourceMappingURL=socket.io.min.js.map
